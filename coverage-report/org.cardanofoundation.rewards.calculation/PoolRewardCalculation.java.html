<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PoolRewardCalculation.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">cardano-reward-calculation</a> &gt; <a href="index.source.html" class="el_package">org.cardanofoundation.rewards.calculation</a> &gt; <span class="el_source">PoolRewardCalculation.java</span></div><h1>PoolRewardCalculation.java</h1><pre class="source lang-java linenums">package org.cardanofoundation.rewards.calculation;

import org.cardanofoundation.rewards.data.provider.DataProvider;
import org.cardanofoundation.rewards.entity.*;
import org.cardanofoundation.rewards.enums.AccountUpdateAction;

import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;

import static org.cardanofoundation.rewards.constants.RewardConstants.TOTAL_LOVELACE;
import static org.cardanofoundation.rewards.util.BigNumberUtils.*;

<span class="nc" id="L16">public class PoolRewardCalculation {</span>

    /*
     * https://github.com/input-output-hk/cardano-ledger/releases/latest/download/shelley-delegation.pdf
     *
     * Calculate the apparent pool performance with the formula (shelley-delegation.pdf page 36):
     *
     * performance = relativeBlocksCreatedInEpoch / relativeActiveStake
     *
     * hint: shelley-delegation.pdf 3.8.3
     *       As long as we have d &gt;= 0.8, we set the apparent performance of any pool to 1
     *
     * See Haskell implementation: https://github.com/input-output-hk/cardano-ledger/blob/64459cc87094331c79d11880e0a4c81b9a721ab0/eras/shelley/impl/src/Cardano/Ledger/Shelley/Rewards.hs#L87C32-L87C44
     */
    public static BigDecimal calculateApparentPoolPerformance(final BigInteger activePoolStake, final BigInteger totalActiveEpochStake, final int blocksMintedByPool, final int blocksMintedByStakePools, final double decentralizationParam) {
<span class="nc" id="L31">        BigDecimal poolStake = new BigDecimal(activePoolStake);</span>
<span class="nc" id="L32">        BigDecimal totalEpochStake = new BigDecimal(totalActiveEpochStake);</span>

<span class="nc bnc" id="L34" title="All 2 branches missed.">        if (decentralizationParam &gt;= 0.8) {</span>
<span class="nc" id="L35">            return BigDecimal.ONE;</span>
<span class="nc bnc" id="L36" title="All 4 branches missed.">        } else if (isZero(poolStake) || isZero(totalEpochStake)) {</span>
<span class="nc" id="L37">            return BigDecimal.ZERO;</span>
        } else {
<span class="nc" id="L39">            final BigDecimal relativeBlocksCreatedInEpoch = divide(blocksMintedByPool, blocksMintedByStakePools);</span>
<span class="nc" id="L40">            final BigDecimal relativeActiveStake = divide(poolStake, totalEpochStake);</span>
<span class="nc" id="L41">            return divide(relativeBlocksCreatedInEpoch, relativeActiveStake);</span>
        }
    }

    /*
     * https://github.com/input-output-hk/cardano-ledger/releases/latest/download/shelley-delegation.pdf
     *
     * Calculate the pool reward with the formula (shelley-delegation.pdf 5.5.3):
     *
     * optimalPoolCount (nOpt &quot;k&quot;) and influence (a0) are
     * protocol parameters: https://cips.cardano.org/cips/cip9/
     *
     * sizeOfASaturatedPool = 1 / optimalPoolCount
     * cappedRelativeStake = min(relativeStakeOfPool, sizeOfASaturatedPool)
     * cappedRelativeStakeOfPoolOwner = min(relativeStakeOfPoolOwner, sizeOfASaturatedPool)
     *
     * rewards = (totalAvailableRewards / (1 + influence)) * (
     *      cappedRelativeStake +
     *      cappedRelativeStakeOfPoolOwner * influence * ((
     *          cappedRelativeStake - cappedRelativeStakeOfPoolOwner *
     *          (( sizeOfASaturatedPool - cappedRelativeStake ) / sizeOfASaturatedPool))
     *          / sizeOfASaturatedPool)
     *      )
     *
     * See the Haskell implementation: https://github.com/input-output-hk/cardano-ledger/blob/e722881568155fc39550a8dfabda3efeb263a1e5/shelley/chain-and-ledger/executable-spec/src/Shelley/Spec/Ledger/EpochBoundary.hs#L111
     */
    public static BigInteger calculateOptimalPoolReward(BigInteger totalAvailableRewards, int optimalPoolCount, double influence, BigDecimal relativeStakeOfPool, BigDecimal relativeStakeOfPoolOwner) {

<span class="nc" id="L69">        BigDecimal sizeOfASaturatedPool = divide(BigDecimal.ONE, optimalPoolCount);</span>
<span class="nc" id="L70">        BigDecimal cappedRelativeStake = min(relativeStakeOfPool, sizeOfASaturatedPool);</span>
<span class="nc" id="L71">        BigDecimal cappedRelativeStakeOfPoolOwner = min(relativeStakeOfPoolOwner, sizeOfASaturatedPool);</span>

        // R / (1 + a0)
        // &quot;R are the total available rewards for the epoch (in ada).&quot; (shelley-delegation.pdf 5.5.3)
<span class="nc" id="L75">        BigDecimal rewardsDividedByOnePlusInfluence = divide(totalAvailableRewards, add(BigDecimal.ONE, influence));</span>

        // (z0 - sigma') / z0
<span class="nc" id="L78">        BigDecimal relativeStakeOfSaturatedPool = divide(subtract(sizeOfASaturatedPool, cappedRelativeStake), sizeOfASaturatedPool);</span>

        // (sigma' - s' * relativeStakeOfSaturatedPool) / z0
<span class="nc" id="L81">        BigDecimal saturatedPoolWeight = divide(subtract(cappedRelativeStake, multiply(cappedRelativeStakeOfPoolOwner, relativeStakeOfSaturatedPool)), sizeOfASaturatedPool);</span>

        // R / (1+a0) * (sigma' + s' * a0 * saturatedPoolWeight)
<span class="nc" id="L84">        return floor(multiply(rewardsDividedByOnePlusInfluence,</span>
<span class="nc" id="L85">                add(cappedRelativeStake, multiply(cappedRelativeStakeOfPoolOwner, influence, saturatedPoolWeight))));</span>
    }

    /*
     *  Calculate the pool reward with the formula (shelley-delegation.pdf 5.5.3 page 37 below):
     *  actualRewards = poolPerformance * optimalPoolReward
     */
    public static BigInteger calculatePoolReward(BigInteger optimalPoolReward, BigDecimal poolPerformance) {
<span class="nc" id="L93">        return floor(multiply(optimalPoolReward, poolPerformance));</span>
    }

    /*
     * This method calculates the pool operator reward regarding the formula described
     * in the shelly-ledger.pdf p. 61, figure 47
     */
    public static BigInteger calculateLeaderReward(BigInteger poolReward, double margin, double poolCost,
                                                   BigDecimal relativeOwnerStake, BigDecimal relativeStakeOfPool) {
<span class="nc bnc" id="L102" title="All 2 branches missed.">        if (isLowerOrEquals(poolReward, poolCost)) {</span>
<span class="nc" id="L103">            return poolReward;</span>
        }

<span class="nc" id="L106">        return add(new BigDecimal(poolCost).toBigInteger(), floor(multiply(subtract(poolReward, poolCost),</span>
<span class="nc" id="L107">                        add(margin, multiply((1 - margin), divide(relativeOwnerStake, relativeStakeOfPool))))));</span>
    }

    /*
     * This method calculates the pool member reward regarding the formula described
     * in the shelly-ledger.pdf p. 61, figure 47
     *
     * See Haskell implementation: https://github.com/input-output-hk/cardano-ledger/blob/aed5dde9cd1096cfc2e255879cd617c0d64f8d9d/eras/shelley/impl/src/Cardano/Ledger/Shelley/Rewards.hs#L117
     */
    public static BigInteger calculateMemberReward(BigInteger poolReward, double margin, double poolCost,
                                               BigDecimal relativeMemberStake, BigDecimal relativeStakeOfPool) {
<span class="nc bnc" id="L118" title="All 2 branches missed.">        if (isLowerOrEquals(poolReward, poolCost)) {</span>
<span class="nc" id="L119">            return BigInteger.ZERO;</span>
        }

<span class="nc" id="L122">        return floor(divide(multiply(</span>
<span class="nc" id="L123">                subtract(poolReward, poolCost),</span>
<span class="nc" id="L124">                subtract(BigDecimal.ONE, margin),</span>
                relativeMemberStake), relativeStakeOfPool));
    }

    public static PoolRewardCalculationResult calculatePoolRewardInEpoch(String poolId, int epoch, DataProvider dataProvider) {
        // Step 1: Get Pool information of current epoch
        // Example: https://api.koios.rest/api/v0/pool_history?_pool_bech32=pool1z5uqdk7dzdxaae5633fqfcu2eqzy3a3rgtuvy087fdld7yws0xt&amp;_epoch_no=210
<span class="nc" id="L131">        PoolRewardCalculationResult poolRewardCalculationResult = PoolRewardCalculationResult.builder()</span>
<span class="nc" id="L132">                .epoch(epoch)</span>
<span class="nc" id="L133">                .poolId(poolId)</span>
<span class="nc" id="L134">                .poolReward(BigInteger.ZERO)</span>
<span class="nc" id="L135">                .build();</span>

<span class="nc" id="L137">        PoolHistory poolHistoryCurrentEpoch = dataProvider.getPoolHistory(poolId, epoch);</span>
<span class="nc bnc" id="L138" title="All 2 branches missed.">        if(poolHistoryCurrentEpoch == null) {</span>
<span class="nc" id="L139">            return poolRewardCalculationResult;</span>
        }

<span class="nc" id="L142">        BigInteger poolStake = poolHistoryCurrentEpoch.getActiveStake();</span>
<span class="nc" id="L143">        BigInteger poolFees = poolHistoryCurrentEpoch.getPoolFees();</span>
<span class="nc" id="L144">        double poolMargin = poolHistoryCurrentEpoch.getMargin();</span>
<span class="nc" id="L145">        double poolFixedCost = poolHistoryCurrentEpoch.getFixedCost();</span>
<span class="nc" id="L146">        int blocksPoolHasMinted = poolHistoryCurrentEpoch.getBlockCount();</span>

<span class="nc" id="L148">        poolRewardCalculationResult.setPoolFee(poolFees);</span>
<span class="nc" id="L149">        poolRewardCalculationResult.setPoolMargin(poolMargin);</span>
<span class="nc" id="L150">        poolRewardCalculationResult.setPoolCost(poolFixedCost);</span>
<span class="nc" id="L151">        poolRewardCalculationResult.setRewardAddress(poolHistoryCurrentEpoch.getRewardAddress());</span>

<span class="nc bnc" id="L153" title="All 2 branches missed.">        if (blocksPoolHasMinted == 0) {</span>
<span class="nc" id="L154">            return poolRewardCalculationResult;</span>
        }

        // Step 2: Get Epoch information of current epoch
        // Source: https://api.koios.rest/api/v0/epoch_info?_epoch_no=211
<span class="nc" id="L159">        Epoch epochInfo = dataProvider.getEpochInfo(epoch);</span>

<span class="nc" id="L161">        BigInteger activeStakeInEpoch = BigInteger.ZERO;</span>
<span class="nc bnc" id="L162" title="All 2 branches missed.">        if (epochInfo.getActiveStake() != null) {</span>
<span class="nc" id="L163">            activeStakeInEpoch = epochInfo.getActiveStake();</span>
        }

        // The Shelley era and the ada pot system started on mainnet in epoch 208.
        // Fee and treasury values are 0 for epoch 208.
<span class="nc" id="L168">        BigInteger totalFeesForCurrentEpoch = BigInteger.ZERO;</span>
<span class="nc bnc" id="L169" title="All 2 branches missed.">        if (epoch &gt; 209) {</span>
<span class="nc" id="L170">            totalFeesForCurrentEpoch = epochInfo.getFees();</span>
        }

<span class="nc" id="L173">        int totalBlocksInEpoch = epochInfo.getBlockCount();</span>

<span class="nc bnc" id="L175" title="All 4 branches missed.">        if (epoch &gt; 212 &amp;&amp; epoch &lt; 255) {</span>
<span class="nc" id="L176">            totalBlocksInEpoch = epochInfo.getNonOBFTBlockCount();</span>
        }

        // Get the ada reserves for the next epoch because it was already updated (int the previous step)
<span class="nc" id="L180">        AdaPots adaPotsForNextEpoch = dataProvider.getAdaPotsForEpoch(epoch + 1);</span>
<span class="nc" id="L181">        BigInteger reserves = adaPotsForNextEpoch.getReserves();</span>

        // Step 3: Get total ada in circulation
<span class="nc" id="L184">        BigInteger adaInCirculation = TOTAL_LOVELACE.subtract(reserves);</span>

        // Step 4: Get protocol parameters for current epoch
<span class="nc" id="L187">        ProtocolParameters protocolParameters = dataProvider.getProtocolParametersForEpoch(epoch);</span>
<span class="nc" id="L188">        double decentralizationParameter = protocolParameters.getDecentralisation();</span>
<span class="nc" id="L189">        int optimalPoolCount = protocolParameters.getOptimalPoolCount();</span>
<span class="nc" id="L190">        double influenceParam = protocolParameters.getPoolOwnerInfluence();</span>
<span class="nc" id="L191">        double monetaryExpandRate = protocolParameters.getMonetaryExpandRate();</span>
<span class="nc" id="L192">        double treasuryGrowRate = protocolParameters.getTreasuryGrowRate();</span>

        // Step 5: Calculate apparent pool performance
<span class="nc" id="L195">        BigDecimal apparentPoolPerformance =</span>
<span class="nc" id="L196">                PoolRewardCalculation.calculateApparentPoolPerformance(poolStake, activeStakeInEpoch,</span>
                        blocksPoolHasMinted, totalBlocksInEpoch, decentralizationParameter);
<span class="nc" id="L198">        poolRewardCalculationResult.setApparentPoolPerformance(apparentPoolPerformance);</span>
        // Step 6: Calculate total available reward for pools (total reward pot after treasury cut)
        // -----
<span class="nc" id="L201">        BigInteger totalRewardPot = TreasuryCalculation.calculateTotalRewardPotWithEta(</span>
                monetaryExpandRate, totalBlocksInEpoch, decentralizationParameter, reserves, totalFeesForCurrentEpoch);

<span class="nc" id="L204">        BigInteger stakePoolRewardsPot = totalRewardPot.subtract(floor(multiply(totalRewardPot, treasuryGrowRate)));</span>
<span class="nc" id="L205">        poolRewardCalculationResult.setStakePoolRewardsPot(stakePoolRewardsPot);</span>
        // shelley-delegation.pdf 5.5.3
        //      &quot;[...]the relative stake of the pool owner(s) (the amount of ada
        //      pledged during pool registration)&quot;

        // Step 7: Get the latest pool update before this epoch and extract the pledge
<span class="nc" id="L211">        double poolPledge = dataProvider.getPoolPledgeInEpoch(poolId, epoch);</span>

<span class="nc" id="L213">        PoolOwnerHistory poolOwnersHistoryInEpoch = dataProvider.getHistoryOfPoolOwnersInEpoch(poolId, epoch);</span>
<span class="nc" id="L214">        BigInteger totalActiveStakeOfOwners = poolOwnersHistoryInEpoch.getActiveStake();</span>
<span class="nc" id="L215">        poolRewardCalculationResult.setPoolOwnerStakeAddresses(poolOwnersHistoryInEpoch.getStakeAddresses());</span>

<span class="nc bnc" id="L217" title="All 2 branches missed.">        if (isLower(totalActiveStakeOfOwners, poolPledge)) {</span>
<span class="nc" id="L218">            return poolRewardCalculationResult;</span>
        }

<span class="nc" id="L221">        BigDecimal relativeStakeOfPoolOwner = divide(poolPledge, adaInCirculation);</span>
<span class="nc" id="L222">        BigDecimal relativePoolStake = divide(poolStake, adaInCirculation);</span>

        // Step 8: Calculate optimal pool reward
<span class="nc" id="L225">        BigInteger optimalPoolReward =</span>
<span class="nc" id="L226">                PoolRewardCalculation.calculateOptimalPoolReward(</span>
                        stakePoolRewardsPot,
                        optimalPoolCount,
                        influenceParam,
                        relativePoolStake,
                        relativeStakeOfPoolOwner);
<span class="nc" id="L232">        poolRewardCalculationResult.setOptimalPoolReward(optimalPoolReward);</span>

        // Step 9: Calculate pool reward as optimal pool reward * apparent pool performance
<span class="nc" id="L235">        BigInteger poolReward = PoolRewardCalculation.calculatePoolReward(optimalPoolReward, apparentPoolPerformance);</span>
<span class="nc" id="L236">        poolRewardCalculationResult.setPoolReward(poolReward);</span>

        // Step 10: Calculate pool operator reward
<span class="nc" id="L239">        BigInteger poolOperatorReward = PoolRewardCalculation.calculateLeaderReward(poolReward, poolMargin, poolFixedCost,</span>
<span class="nc" id="L240">                divide(totalActiveStakeOfOwners, adaInCirculation), relativePoolStake);</span>

        // Step 10 a: Check if pool reward address has been unregistered before
<span class="nc" id="L243">        List&lt;AccountUpdate&gt; accountUpdates = dataProvider.getAccountUpdatesUntilEpoch(List.of(poolRewardCalculationResult.getRewardAddress()), epoch);</span>
<span class="nc" id="L244">        accountUpdates = accountUpdates.stream().filter(update -&gt;</span>
<span class="nc bnc" id="L245" title="All 2 branches missed.">                update.getAction().equals(AccountUpdateAction.DEREGISTRATION)</span>
<span class="nc bnc" id="L246" title="All 2 branches missed.">                        || update.getAction().equals(AccountUpdateAction.REGISTRATION)).sorted(</span>
<span class="nc" id="L247">                Comparator.comparing(AccountUpdate::getUnixBlockTime).reversed()).toList();</span>

<span class="nc bnc" id="L249" title="All 4 branches missed.">        if (accountUpdates.size() &gt; 0 &amp;&amp; accountUpdates.get(0).getAction().equals(AccountUpdateAction.DEREGISTRATION)) {</span>
<span class="nc" id="L250">            poolOperatorReward = BigInteger.ZERO;</span>
        }

<span class="nc" id="L253">        poolOperatorReward = poolOperatorReward.add(correctOutliers(poolId, epoch + 2));</span>

<span class="nc" id="L255">        poolRewardCalculationResult.setOperatorReward(poolOperatorReward);</span>
        // Step 11: Calculate pool member reward
<span class="nc" id="L257">        List&lt;Reward&gt; memberRewards = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L258" title="All 2 branches missed.">        for (Delegator delegator : poolHistoryCurrentEpoch.getDelegators()) {</span>
<span class="nc" id="L259">            accountUpdates = dataProvider.getAccountUpdatesUntilEpoch(List.of(delegator.getStakeAddress()), epoch);</span>
<span class="nc bnc" id="L260" title="All 4 branches missed.">            if (accountUpdates.size() &gt; 0 &amp;&amp; accountUpdates.get(0).getAction().equals(AccountUpdateAction.DEREGISTRATION)) {</span>
<span class="nc" id="L261">                continue;</span>
            }

<span class="nc" id="L264">            BigInteger memberReward = PoolRewardCalculation.calculateMemberReward(poolReward, poolMargin,</span>
<span class="nc" id="L265">                    poolFixedCost, divide(delegator.getActiveStake(), adaInCirculation), relativePoolStake);</span>
<span class="nc" id="L266">            memberRewards.add(Reward.builder()</span>
<span class="nc" id="L267">                    .amount(memberReward)</span>
<span class="nc" id="L268">                    .stakeAddress(delegator.getStakeAddress())</span>
<span class="nc" id="L269">                    .build());</span>
<span class="nc" id="L270">        }</span>
<span class="nc" id="L271">        poolRewardCalculationResult.setMemberRewards(memberRewards);</span>
<span class="nc" id="L272">        return poolRewardCalculationResult;</span>
    }

    /*
        TODO:   Replace this method with the jpa repository call to find reward address owning
                multiple pools that produced blocks in the same epoch
     */
    public static BigInteger correctOutliers(String poolId, int epoch) {
<span class="nc" id="L280">        BigInteger correction = BigInteger.ZERO;</span>

<span class="nc bnc" id="L282" title="All 4 branches missed.">        if (epoch == 214 &amp;&amp; poolId.equals(&quot;pool13l0j202yexqh6l0awtee9g354244gmfze09utxz0sn7p7r3ev3m&quot;)) {</span>
            /*
             * The reward_address of pool13l0j202yexqh6l0awtee9g354244gmfze09utxz0sn7p7r3ev3m is also the
             * reward_address of pool1gh4cj5h5glk5992d0wtela324htr0cn8ujvg53pmuds9guxgz2u. Both pools produced
             * blocks in epoch 214. In a previous node version this caused an outlier where the
             * leader rewards of pool13l0j202yexqh6l0awtee9g354244gmfze09utxz0sn7p7r3ev3m has been set to 0.
             *
             * This behavior has been changed later so that the owner would receive leader rewards for both pools.
             * Affected reward addresses have been paid out due to a MIR certificate afterward.
             */
<span class="nc" id="L292">            correction = new BigInteger(String.valueOf(-814592210));</span>
<span class="nc bnc" id="L293" title="All 4 branches missed.">        } else if (epoch == 214 &amp;&amp; poolId.equals(&quot;pool166dkk9kx5y6ug9tnvh0dnvxhwt2yca3g5pd5jaqa8t39cgyqqlr&quot;)) {</span>
            // pool1qvvn2l690zm3v2p0f3vd66ly6cfs2wjqx34zpqcx5pwsx3eprtp also produced blocks in epoch 214
            // with the same reward address
<span class="nc" id="L296">            correction = new BigInteger(String.valueOf(-669930045));</span>
<span class="nc bnc" id="L297" title="All 4 branches missed.">        } else if (epoch == 215 &amp;&amp; poolId.equals(&quot;pool166dkk9kx5y6ug9tnvh0dnvxhwt2yca3g5pd5jaqa8t39cgyqqlr&quot;)) {</span>
            // pool1qvvn2l690zm3v2p0f3vd66ly6cfs2wjqx34zpqcx5pwsx3eprtp also produced blocks in epoch 215
            // with the same reward address
<span class="nc" id="L300">            correction = new BigInteger(String.valueOf(-634057195));</span>
<span class="nc bnc" id="L301" title="All 4 branches missed.">        } else if (epoch == 215 &amp;&amp; poolId.equals(&quot;pool17rns3wjyql9jg9xkzw9h88f0kstd693pm6urwxmvejqgsyjw7ta&quot;)) {</span>
            // pool12crd62rxj8yryvshmgwkxza7um3uhaypwdjeel98lnkf529qdw5 &amp;
            // pool1v4adhelnswa7pwv2njn5h84atw08mlc79ll2ewl2kgxhv3cqwql also produced blocks in epoch 215
            // with the same reward address
<span class="nc" id="L305">            correction = new BigInteger(String.valueOf(-369216375.99999997));</span>
        }

<span class="nc" id="L308">        return correction;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>