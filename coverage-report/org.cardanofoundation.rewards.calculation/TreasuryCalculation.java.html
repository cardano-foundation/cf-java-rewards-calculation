<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TreasuryCalculation.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">cardano-reward-calculation</a> &gt; <a href="index.source.html" class="el_package">org.cardanofoundation.rewards.calculation</a> &gt; <span class="el_source">TreasuryCalculation.java</span></div><h1>TreasuryCalculation.java</h1><pre class="source lang-java linenums">package org.cardanofoundation.rewards.calculation;

import org.cardanofoundation.rewards.data.provider.DataProvider;
import org.cardanofoundation.rewards.entity.*;
import org.cardanofoundation.rewards.enums.AccountUpdateAction;
import org.cardanofoundation.rewards.enums.MirPot;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;

import static org.cardanofoundation.rewards.constants.RewardConstants.*;

<span class="nc" id="L14">public class TreasuryCalculation {</span>

  /*
   * Calculate the treasury for epoch e with the formula:
   *
   * treasury(e) = treasury_growth_rate * reward_pot + treasury(e - 1)
   * treasury(e) = 0, if e &lt; 209
   */
  public static double calculateTreasury(double treasuryGrowRate, double rewardPot, double lastTreasury) {
<span class="fc" id="L23">    return rewardPot * treasuryGrowRate + lastTreasury;</span>
  }

  /*
   * Calculate the reward pot for epoch e with the formula:
   *
   * rewards(e) = floor(monetary_expand_rate * eta * reserve(e - 1) + fee(e - 1))
   * rewards(e) = 0, if e &lt; 209
   */
  public static double calculateTotalRewardPotWithEta(double monetaryExpandRate, int totalBlocksInEpochByPools,
                                                         double decentralizationParameter, double reserve, double fee) {
<span class="fc" id="L34">    double eta = calculateEta(totalBlocksInEpochByPools, decentralizationParameter);</span>
<span class="fc" id="L35">    return Math.floor(reserve * monetaryExpandRate * eta) + fee;</span>
  }

  /*
  * Calculate eta using the decentralisation parameter and the formula:
  *
  * eta(totalBlocksInEpochMadeByPools, decentralisation) = 1, if decentralisation &gt;= 0.8, otherwise
  * eta(totalBlocksInEpochMadeByPools, decentralisation) =
  *   min(1, totalBlocksInEpochMadeByPools / ((1 - decentralisation) * expectedSlotPerEpoch * activeSlotsCoeff))
  *
  * See: https://github.com/input-output-hk/cardano-ledger/commit/c4f10d286faadcec9e4437411bce9c6c3b6e51c2
  */
  private static double calculateEta(int totalBlocksInEpochByPools, double decentralizationParameter) {
    // shelley-delegation.pdf 5.4.3

<span class="fc bfc" id="L50" title="All 2 branches covered.">    if (decentralizationParameter &gt;= 0.8) {</span>
<span class="fc" id="L51">      return 1.0;</span>
    }

    // The number of expected blocks will be the number of slots per epoch times the active slots coefficient
<span class="fc" id="L55">    double activeSlotsCoeff = 0.05; // See: Non-Updatable Parameters: https://cips.cardano.org/cips/cip9/</span>

    // decentralizationParameter is the proportion of blocks that are expected to be produced by stake pools
    // instead of the OBFT (Ouroboros Byzantine Fault Tolerance) nodes. It was introduced close before the Shelley era:
    // https://github.com/input-output-hk/cardano-ledger/commit/c4f10d286faadcec9e4437411bce9c6c3b6e51c2
<span class="fc" id="L60">    double expectedBlocksInNonOBFTSlots = EXPECTED_SLOT_PER_EPOCH * activeSlotsCoeff * (1 - decentralizationParameter);</span>

    // eta is the ratio between the number of blocks that have been produced during the epoch, and
    // the expectation value of blocks that should have been produced during the epoch under
    // ideal conditions.
<span class="fc" id="L65">    return Math.min(1, totalBlocksInEpochByPools / expectedBlocksInNonOBFTSlots);</span>
  }

  public static TreasuryCalculationResult calculateTreasuryForEpoch(int epoch, DataProvider dataProvider) {
<span class="fc" id="L69">    ProtocolParameters protocolParameters = dataProvider.getProtocolParametersForEpoch(epoch - 2);</span>
<span class="fc" id="L70">    final double treasuryGrowthRate = protocolParameters.getTreasuryGrowRate();</span>
<span class="fc" id="L71">    final double monetaryExpandRate = protocolParameters.getMonetaryExpandRate();</span>
<span class="fc" id="L72">    double decentralizationParameter = protocolParameters.getDecentralisation();</span>

<span class="fc" id="L74">    AdaPots adaPotsForPreviousEpoch = dataProvider.getAdaPotsForEpoch(epoch - 1);</span>
<span class="fc" id="L75">    AdaPots adaPotsForCurrentEpoch = dataProvider.getAdaPotsForEpoch(epoch);</span>

    // The Shelley era and the ada pot system started on mainnet in epoch 208.
    // Fee and treasury values are 0 for epoch 208.
<span class="fc" id="L79">    double totalFeesForCurrentEpoch = 0.0;</span>
<span class="fc" id="L80">    Epoch epochInfo = dataProvider.getEpochInfo(epoch - 2);</span>
<span class="pc bpc" id="L81" title="1 of 2 branches missed.">    if (epoch &gt; 209) {</span>
<span class="fc" id="L82">      totalFeesForCurrentEpoch = epochInfo.getFees();</span>
    }

<span class="fc" id="L85">    double reserveInPreviousEpoch = adaPotsForPreviousEpoch.getReserves();</span>

<span class="fc" id="L87">    double treasuryInPreviousEpoch = adaPotsForPreviousEpoch.getTreasury();</span>
<span class="fc" id="L88">    double expectedTreasuryForCurrentEpoch = adaPotsForCurrentEpoch.getTreasury();</span>

<span class="fc" id="L90">    int totalBlocksInEpoch = epochInfo.getBlockCount();</span>

<span class="pc bpc" id="L92" title="3 of 4 branches missed.">    if (decentralizationParameter &lt; 0.8 &amp;&amp; decentralizationParameter &gt; 0.0) {</span>
<span class="nc" id="L93">      totalBlocksInEpoch = epochInfo.getNonOBFTBlockCount();</span>
    }

<span class="fc" id="L96">    double rewardPot = TreasuryCalculation.calculateTotalRewardPotWithEta(</span>
            monetaryExpandRate, totalBlocksInEpoch, decentralizationParameter, reserveInPreviousEpoch, totalFeesForCurrentEpoch);

<span class="fc" id="L99">    double treasuryForCurrentEpoch = TreasuryCalculation.calculateTreasury(</span>
            treasuryGrowthRate, rewardPot, treasuryInPreviousEpoch);

    // The sum of all the refunds attached to unregistered reward accounts are added to the
    // treasury (see: Pool Reap Transition, p.53, figure 40, shely-ledger.pdf)
<span class="fc" id="L104">    treasuryForCurrentEpoch += TreasuryCalculation.calculateUnclaimedRefundsForRetiredPools(epoch, dataProvider);</span>

    // Check if there was a MIR Certificate in the previous epoch
<span class="fc" id="L107">    List&lt;MirCertificate&gt; mirCertificates = dataProvider.getMirCertificatesInEpoch(epoch - 1);</span>
<span class="pc bpc" id="L108" title="1 of 2 branches missed.">    for (MirCertificate mirCertificate : mirCertificates) {</span>
<span class="nc bnc" id="L109" title="All 2 branches missed.">      if (mirCertificate.getPot() == MirPot.TREASURY) {</span>
<span class="nc" id="L110">        treasuryForCurrentEpoch -= mirCertificate.getTotalRewards();</span>
      }
<span class="nc" id="L112">    }</span>

<span class="fc" id="L114">    return TreasuryCalculationResult.builder()</span>
<span class="fc" id="L115">            .calculatedTreasury(treasuryForCurrentEpoch)</span>
<span class="fc" id="L116">            .actualTreasury(expectedTreasuryForCurrentEpoch)</span>
<span class="fc" id="L117">            .epoch(epoch)</span>
<span class="fc" id="L118">            .totalRewardPot(rewardPot)</span>
<span class="fc" id="L119">            .build();</span>
  }

  /*
    &quot;For each retiring pool, the refund for the pool registration deposit is added to the
    pool's registered reward account, provided the reward account is still registered.&quot; -
    https://github.com/input-output-hk/cardano-ledger/blob/9e2f8151e3b9a0dde9faeb29a7dd2456e854427c/eras/shelley/formal-spec/epoch.tex#L546C9-L547C87
   */
  public static Double calculateUnclaimedRefundsForRetiredPools(int epoch, DataProvider dataProvider) {
<span class="fc" id="L128">    List&lt;PoolDeregistration&gt; retiredPools = dataProvider.getRetiredPoolsInEpoch(epoch);</span>

<span class="fc" id="L130">    double refunds = 0.0;</span>

<span class="pc bpc" id="L132" title="1 of 2 branches missed.">    if (retiredPools.size() &gt; 0) {</span>
      // The deposit will pay back one epoch later
<span class="fc" id="L134">      List&lt;AccountUpdate&gt; accountUpdates = dataProvider.getAccountUpdatesUntilEpoch(</span>
<span class="fc" id="L135">              retiredPools.stream().map(PoolDeregistration::getRewardAddress).toList(), epoch - 1);</span>

      // Order list by unix block time
<span class="fc" id="L138">      accountUpdates = accountUpdates.stream().filter(update -&gt;</span>
<span class="fc bfc" id="L139" title="All 2 branches covered.">              update.getAction().equals(AccountUpdateAction.DEREGISTRATION)</span>
<span class="fc bfc" id="L140" title="All 2 branches covered.">              || update.getAction().equals(AccountUpdateAction.REGISTRATION)).sorted(</span>
<span class="fc" id="L141">              Comparator.comparing(AccountUpdate::getUnixBlockTime).reversed()).toList();</span>

      // only hold the latest account update for each reward address
      // preventing the case of an unregistered reward address becoming registered again
<span class="fc" id="L145">      List&lt;AccountUpdate&gt; latestAccountUpdates = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L146" title="All 2 branches covered.">      for (AccountUpdate accountUpdate : accountUpdates) {</span>
<span class="fc bfc" id="L147" title="All 2 branches covered.">        if (latestAccountUpdates.stream().map(AccountUpdate::getStakeAddress).noneMatch(stakeAddress -&gt; stakeAddress.equals(accountUpdate.getStakeAddress()))) {</span>
<span class="fc" id="L148">          latestAccountUpdates.add(accountUpdate);</span>
        }
<span class="fc" id="L150">      }</span>

<span class="fc bfc" id="L152" title="All 2 branches covered.">      for (AccountUpdate lastAccountUpdate : latestAccountUpdates) {</span>
<span class="fc bfc" id="L153" title="All 2 branches covered.">        if (lastAccountUpdate.getAction() == AccountUpdateAction.DEREGISTRATION) {</span>
<span class="fc" id="L154">          refunds += DEPOSIT_POOL_REGISTRATION_IN_LOVELACE;</span>
        }
<span class="fc" id="L156">      }</span>
    }

<span class="fc" id="L159">    return refunds;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>