<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RewardServiceImpl.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">cardano-reward-calculation</a> &gt; <a href="index.source.html" class="el_package">org.cardanofoundation.rewards.service.impl</a> &gt; <span class="el_source">RewardServiceImpl.java</span></div><h1>RewardServiceImpl.java</h1><pre class="source lang-java linenums">package org.cardanofoundation.rewards.service.impl;

import java.math.BigDecimal;
import java.math.BigInteger;
import java.math.MathContext;
import java.math.RoundingMode;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.stream.Collectors;

import lombok.AccessLevel;
import lombok.RequiredArgsConstructor;
import lombok.experimental.FieldDefaults;
import lombok.extern.slf4j.Slf4j;

import org.cardanofoundation.rewards.common.entity.*;
import org.cardanofoundation.rewards.constants.RewardConstants;
import org.cardanofoundation.rewards.service.*;
import org.springframework.stereotype.Service;

import org.cardanofoundation.rewards.projection.PoolConfigProjection;
import org.cardanofoundation.rewards.repository.PoolOwnerRepository;
import org.cardanofoundation.rewards.repository.RewardRepository;
import org.cardanofoundation.rewards.repository.SlotLeaderRepository;
import org.cardanofoundation.rewards.repository.WithdrawalRepository;

<span class="fc" id="L28">@Slf4j</span>
@FieldDefaults(level = AccessLevel.PRIVATE, makeFinal = true)
<span class="fc" id="L30">@RequiredArgsConstructor</span>
@Service
public class RewardServiceImpl implements RewardService {

  EpochParamService epochParamService;
  RewardRepository rewardRepository;
  WithdrawalRepository withdrawalRepository;
  PoolUpdateService poolUpdateService;
  EpochStakeService epochStakeService;
  PoolOwnerRepository poolOwnerRepository;
  TxService txService;
  StakeAddressService stakeAddressService;
  PoolService poolService;
  SlotLeaderRepository slotLeaderRepository;

  @Override
  public BigInteger getTotalRemainRewardOfEpoch(int epoch) {
<span class="nc" id="L47">    var totalReward = getNonNullAmount(rewardRepository.getTotalRewardToEpoch(epoch));</span>
<span class="nc" id="L48">    log.info(&quot;Total reward to the end of epoch {} is {}&quot;, epoch, totalReward);</span>
<span class="nc" id="L49">    var totalWithdrawal =</span>
<span class="nc" id="L50">        getNonNullAmount(withdrawalRepository.getTotalWithdrawalToEndEpoch(epoch - 1));</span>
<span class="nc" id="L51">    log.info(&quot;Total withdrawal to the end of epoch {} is {}&quot;, epoch, totalWithdrawal);</span>
<span class="nc" id="L52">    var remainReward = totalReward.subtract(totalWithdrawal);</span>
<span class="nc" id="L53">    log.info(&quot;Remain reward to epoch {} is {}&quot;, epoch, remainReward);</span>
<span class="nc" id="L54">    return remainReward;</span>
  }

  private BigInteger getNonNullAmount(BigInteger amount) {
<span class="nc bnc" id="L58" title="All 2 branches missed.">    if (Objects.isNull(amount)) {</span>
<span class="nc" id="L59">      amount = BigInteger.ZERO;</span>
    }
<span class="nc" id="L61">    return amount;</span>
  }

  @Override
  public BigInteger getTotalRewardOfEpochByType(int epoch, RewardType rewardType) {
<span class="nc" id="L66">    return getNonNullAmount(rewardRepository.getTotalRewardOfEpochByType(epoch, rewardType));</span>
  }

  @Override
  public BigInteger getDistributedReward(int epoch) {
<span class="nc" id="L71">    return getNonNullAmount(rewardRepository.getTotalSpendableRewardExcludeRefund(epoch));</span>
  }

  @Override
  public Collection&lt;Reward&gt; calculateReward(int epoch, BigInteger reserves, BigInteger fee) {
<span class="nc" id="L76">    var epochReward = epoch - 1;</span>
<span class="nc" id="L77">    var epochParamOpt = epochParamService.getEpochParam(epochReward);</span>
<span class="nc bnc" id="L78" title="All 2 branches missed.">    if (epochParamOpt.isEmpty()) {</span>
<span class="nc" id="L79">      log.warn(&quot;Found no epoch param with epoch no: {}&quot;, epochReward);</span>
<span class="nc" id="L80">      return Collections.emptyList();</span>
    }
<span class="nc" id="L82">    var epochParam = epochParamOpt.get();</span>
    // this stake address map use to later filter which stake address is pool owner's, which
    // stake address is member's

    // for each active pool of this epoch, calculate and insert rewards
<span class="nc" id="L87">    var poolConfigs = poolUpdateService.findPoolHasMintedBlockInEpoch(epochReward);</span>
<span class="nc" id="L88">    log.info(&quot;Reward pool size minted block {}&quot;, poolConfigs.size());</span>
<span class="nc bnc" id="L89" title="All 2 branches missed.">    if (poolConfigs.isEmpty()) {</span>
<span class="nc" id="L90">      return new ArrayList&lt;&gt;();</span>
    }

<span class="nc" id="L93">    var poolUpdateIds =</span>
<span class="nc" id="L94">        poolConfigs.stream().map(PoolConfigProjection::getPoolUpdateId).collect(Collectors.toSet());</span>
<span class="nc" id="L95">    var poolOwners = poolOwnerRepository.findAllPoolOwnerByPoolUpdateIds(poolUpdateIds);</span>
<span class="nc" id="L96">    Map&lt;Long, Set&lt;Long&gt;&gt; mPoolUpdateIdAndPoolOwner = new ConcurrentHashMap&lt;&gt;();</span>
<span class="nc" id="L97">    poolOwners.forEach(</span>
        poolOwner -&gt; {
<span class="nc" id="L99">          var puId = poolOwner.getPoolUpdateId();</span>
<span class="nc bnc" id="L100" title="All 2 branches missed.">          if (mPoolUpdateIdAndPoolOwner.containsKey(puId)) {</span>
<span class="nc" id="L101">            mPoolUpdateIdAndPoolOwner.get(puId).add(poolOwner.getStakeAddressId());</span>
          } else {
<span class="nc" id="L103">            mPoolUpdateIdAndPoolOwner.put(</span>
<span class="nc" id="L104">                puId, new HashSet&lt;&gt;(Collections.singletonList(poolOwner.getStakeAddressId())));</span>
          }
<span class="nc" id="L106">        });</span>

    // get all activate stake of epoch will get reward
<span class="nc" id="L109">    var stakeBalances = epochStakeService.getAllEpochStakeByEpochNo(epochReward);</span>
<span class="nc" id="L110">    var txIdSnapshot = txService.getTxIdLedgerSnapshotOfEpoch(epoch + 1);</span>
<span class="nc" id="L111">    var totalBlockMinted = slotLeaderRepository.countBlockMintedByPoolInEpoch(epochReward);</span>
<span class="nc" id="L112">    var sStakeAddressIds =</span>
<span class="nc" id="L113">        stakeBalances.stream().map(EpochStake::getStakeAddressId).collect(Collectors.toSet());</span>
<span class="nc" id="L114">    log.info(&quot;Reward epoch {} stake size {}&quot;, epochReward, stakeBalances.size());</span>
<span class="nc" id="L115">    Collection&lt;Reward&gt; stakeRewards = new ConcurrentLinkedQueue&lt;&gt;();</span>

<span class="nc" id="L117">    var leaderAddresses =</span>
<span class="nc" id="L118">        poolConfigs.stream()</span>
<span class="nc" id="L119">            .map(PoolConfigProjection::getRewardAddressId)</span>
<span class="nc" id="L120">            .collect(Collectors.toSet());</span>
<span class="nc" id="L121">    sStakeAddressIds.addAll(leaderAddresses);</span>

<span class="nc" id="L123">    var stakeAddressesAreRegistered =</span>
<span class="nc" id="L124">        stakeAddressService.getStakeAddressRegisteredTilEpoch(</span>
            txIdSnapshot, sStakeAddressIds, epoch + 1);
<span class="nc" id="L126">    Map&lt;Long, BigDecimal&gt; poolsPerformance =</span>
<span class="nc" id="L127">        poolService.getPoolPerformanceInEpoch(epochReward, stakeBalances);</span>

<span class="nc" id="L129">    Map&lt;Long, List&lt;EpochStake&gt;&gt; mPoolIdAndEpochStakes =</span>
<span class="nc" id="L130">        stakeBalances.stream().collect(Collectors.groupingBy(EpochStake::getPoolId));</span>

<span class="nc" id="L132">    poolConfigs.parallelStream()</span>
<span class="nc" id="L133">        .forEach(</span>
            poolConfig -&gt;
<span class="nc" id="L135">                stakeRewards.addAll(</span>
<span class="nc" id="L136">                    calculateRewardsOfAPool(</span>
                        poolConfig,
                        reserves,
                        fee,
                        epochParam,
<span class="nc" id="L141">                        mPoolIdAndEpochStakes.get(poolConfig.getPoolId()),</span>
                        epochReward,
<span class="nc" id="L143">                        mPoolUpdateIdAndPoolOwner.get(poolConfig.getPoolUpdateId()),</span>
                        stakeAddressesAreRegistered,
<span class="nc" id="L145">                        poolsPerformance.get(poolConfig.getPoolId()),</span>
<span class="nc" id="L146">                        totalBlockMinted)));</span>

<span class="nc" id="L148">    epochStakeService.removeCacheEpochStakeByEpochNo(epochReward);</span>
<span class="nc" id="L149">    return stakeRewards;</span>
  }

  public Collection&lt;Reward&gt; calculateRewardsOfAPool(
      PoolConfigProjection poolConfigProjection,
      BigInteger reserves,
      BigInteger fee,
      EpochParam epochParam,
      List&lt;EpochStake&gt; epochStakeOfPool,
      int epochNo,
      Set&lt;Long&gt; poolOwnerAddrIds,
      Set&lt;Long&gt; stakeAddressIdsAreRegistered,
      BigDecimal poolPerformance,
      int totalBlockMinted) {
<span class="fc" id="L163">    var totalStakeOfPool = calculateTotalStakeOfPool(epochStakeOfPool);</span>
<span class="fc" id="L164">    var poolOwnerPledge = new BigDecimal(poolConfigProjection.getPledge());</span>
<span class="fc" id="L165">    var totalAda = new BigDecimal(RewardConstants.TOTAL_ADA).subtract(new BigDecimal(reserves));</span>

<span class="fc" id="L167">    var totalStakeOfPoolOwner =</span>
<span class="fc" id="L168">        epochStakeOfPool.stream()</span>
<span class="fc" id="L169">            .filter(epochStake -&gt; poolOwnerAddrIds.contains(epochStake.getStakeAddressId()))</span>
<span class="fc" id="L170">            .map(EpochStake::getAmount)</span>
<span class="fc" id="L171">            .reduce(BigInteger.ZERO, BigInteger::add);</span>
    // sigma in the formula
<span class="fc" id="L173">    var relativeStakeOfPool = totalStakeOfPool.divide(totalAda, 30, RoundingMode.DOWN);</span>
    // s in the formula
<span class="fc" id="L175">    var relativePledgeStakeOfPoolOwner = poolOwnerPledge.divide(totalAda, 30, RoundingMode.DOWN);</span>

<span class="fc" id="L177">    List&lt;Reward&gt; stakeRewards = new ArrayList&lt;&gt;();</span>

    // If pool owner stake not enough with pledge so the pool will get no reward
<span class="pc bpc" id="L180" title="1 of 2 branches missed.">    if (totalStakeOfPoolOwner.compareTo(poolConfigProjection.getPledge()) &lt; 0) {</span>
<span class="nc" id="L181">      log.warn(</span>
          &quot;Pool {} will not get reward because owner stake {} is smaller than pledge {}&quot;,
<span class="nc" id="L183">          poolConfigProjection.getPoolId(),</span>
          totalStakeOfPoolOwner,
<span class="nc" id="L185">          poolConfigProjection.getPledge());</span>
      // leader will get zero reward
<span class="nc" id="L187">      stakeRewards.add(Reward.builder()</span>
<span class="nc" id="L188">          .type(RewardType.LEADER)</span>
<span class="nc" id="L189">          .earnedEpoch(epochNo)</span>
<span class="nc" id="L190">          .spendableEpoch(epochNo + 2)</span>
<span class="nc" id="L191">          .addr(StakeAddress.builder().id(poolConfigProjection.getRewardAddressId()).build())</span>
<span class="nc" id="L192">          .stakeAddressId(poolConfigProjection.getRewardAddressId())</span>
<span class="nc" id="L193">          .pool(PoolHash.builder().id(poolConfigProjection.getPoolId()).build())</span>
<span class="nc" id="L194">          .poolId(poolConfigProjection.getPoolId())</span>
<span class="nc" id="L195">          .amount(BigInteger.ZERO)</span>
<span class="nc" id="L196">          .build());</span>
<span class="nc" id="L197">      return stakeRewards;</span>
    }

<span class="fc" id="L200">    var relativeStakeOfPoolOwner =</span>
<span class="fc" id="L201">        new BigDecimal(totalStakeOfPoolOwner).divide(totalAda, 30, RoundingMode.DOWN);</span>

<span class="fc" id="L203">    BigDecimal poolReward =</span>
<span class="fc" id="L204">        calculatePoolReward(</span>
            epochParam,
            reserves,
            fee,
            relativeStakeOfPool,
            relativePledgeStakeOfPoolOwner,
            poolPerformance,
            totalBlockMinted);

    // For each stake address, calculate reward
<span class="fc" id="L214">    epochStakeOfPool.forEach(</span>
        stakeBalance -&gt; {
          // this stake address is a member's stake address, calculate pool member
<span class="fc bfc" id="L217" title="All 2 branches covered.">          if (!poolOwnerAddrIds.contains(stakeBalance.getStakeAddressId())</span>
              &amp;&amp; !stakeBalance
<span class="fc" id="L219">              .getStakeAddressId()</span>
<span class="fc bfc" id="L220" title="All 2 branches covered.">              .equals(poolConfigProjection.getRewardAddressId())) {</span>
            // reward
<span class="fc" id="L222">            var stakeBalanceOfMember = new BigDecimal(stakeBalance.getAmount());</span>
            // t in the formula
<span class="fc" id="L224">            var relativeStakeOfMember =</span>
<span class="fc" id="L225">                stakeBalanceOfMember.divide(totalAda, 30, RoundingMode.DOWN);</span>

            RewardParam param =
<span class="fc" id="L228">                RewardParam.builder()</span>
<span class="fc" id="L229">                    .stakeAddressId(stakeBalance.getStakeAddressId())</span>
<span class="fc" id="L230">                    .relativeStake(relativeStakeOfMember)</span>
<span class="fc" id="L231">                    .poolReward(poolReward.setScale(0, RoundingMode.DOWN))</span>
<span class="fc" id="L232">                    .relativeStakeOfPool(relativeStakeOfPool)</span>
<span class="fc" id="L233">                    .poolConfigProjection(poolConfigProjection)</span>
<span class="fc" id="L234">                    .epochNo(epochNo)</span>
<span class="fc" id="L235">                    .build();</span>

<span class="fc" id="L237">            Reward memberReward = calculateMemberReward(param);</span>
<span class="fc bfc" id="L238" title="All 2 branches covered.">            if (memberReward.getAmount().compareTo(BigInteger.ZERO) &gt; 0) {</span>
<span class="pc bpc" id="L239" title="1 of 2 branches missed.">              if (stakeAddressIdsAreRegistered.contains(stakeBalance.getStakeAddressId())) {</span>
<span class="fc" id="L240">                stakeRewards.add(memberReward);</span>
              } else {
<span class="nc" id="L242">                log.debug(</span>
                    &quot;Stake {} of pool {} wouldn't earn member reward with amount {}&quot;,
<span class="nc" id="L244">                    memberReward.getStakeAddressId(),</span>
<span class="nc" id="L245">                    memberReward.getPoolId(),</span>
<span class="nc" id="L246">                    memberReward.getAmount());</span>
              }
            }
          }
<span class="fc" id="L250">        });</span>
    RewardParam param =
<span class="fc" id="L252">        RewardParam.builder()</span>
<span class="fc" id="L253">            .stakeAddressId(poolConfigProjection.getRewardAddressId())</span>
<span class="fc" id="L254">            .relativeStake(relativeStakeOfPoolOwner)</span>
<span class="fc" id="L255">            .poolReward(poolReward.setScale(0, RoundingMode.DOWN))</span>
<span class="fc" id="L256">            .relativeStakeOfPool(relativeStakeOfPool)</span>
<span class="fc" id="L257">            .poolConfigProjection(poolConfigProjection)</span>
<span class="fc" id="L258">            .epochNo(epochNo)</span>
<span class="fc" id="L259">            .build();</span>

<span class="fc" id="L261">    Reward poolOwnerReward = calculatePoolOwnerReward(param);</span>
    // Leader reward can earn if reward address stake registration is activated
<span class="fc bfc" id="L263" title="All 2 branches covered.">    if (stakeAddressIdsAreRegistered.contains(poolConfigProjection.getRewardAddressId())) {</span>
<span class="fc" id="L264">      stakeRewards.add(poolOwnerReward);</span>
    } else {
<span class="fc" id="L266">      log.debug(</span>
          &quot;Pool {} in epoch {} wouldn't earn leader reward because reward address {} didn't have registered yet amount {}&quot;,
<span class="fc" id="L268">          poolConfigProjection.getPoolId(),</span>
<span class="fc" id="L269">          epochNo + 2,</span>
<span class="fc" id="L270">          poolConfigProjection.getRewardAddressId(),</span>
<span class="fc" id="L271">          poolOwnerReward.getAmount());</span>
    }
<span class="fc" id="L273">    return stakeRewards;</span>
  }

  private BigDecimal calculateTotalStakeOfPool(List&lt;EpochStake&gt; stakeBalances) {
<span class="fc" id="L277">    var totalStake =</span>
<span class="fc" id="L278">        stakeBalances.stream().map(EpochStake::getAmount).reduce(BigInteger.ZERO, BigInteger::add);</span>
<span class="fc" id="L279">    return new BigDecimal(totalStake);</span>
  }

  public BigDecimal calculatePoolReward(
      EpochParam epochParam,
      BigInteger reserves,
      BigInteger fee,
      BigDecimal relativeStakeOfPool,
      BigDecimal relativeStakeOfPoolOwner,
      BigDecimal poolPerformance,
      int totalBlockMinted) {

    // R in the formula
<span class="fc" id="L292">    var totalAvailableRewardOfEpoch =</span>
<span class="fc" id="L293">        calculateTotalAvailableReward(reserves, fee, epochParam, totalBlockMinted)</span>
<span class="fc" id="L294">            .setScale(0, RoundingMode.DOWN);</span>
<span class="fc" id="L295">    var a0 = new BigDecimal(epochParam.getInfluence().toString());</span>
<span class="fc" id="L296">    var z0 =</span>
<span class="fc" id="L297">        BigDecimal.ONE.divide(</span>
<span class="fc" id="L298">            new BigDecimal(epochParam.getOptimalPoolCount()), 30, RoundingMode.DOWN);</span>

    // sigma' in the formula
<span class="fc" id="L301">    var min1 = z0.min(relativeStakeOfPool);</span>
    // s' in the formula
<span class="fc" id="L303">    var min2 = z0.min(relativeStakeOfPoolOwner);</span>
<span class="fc" id="L304">    MathContext mc = new MathContext(30, RoundingMode.DOWN);</span>
<span class="fc" id="L305">    return (totalAvailableRewardOfEpoch.divide(BigDecimal.ONE.add(a0), 30, RoundingMode.DOWN))</span>
<span class="fc" id="L306">        .multiply(</span>
<span class="fc" id="L307">            min1.add(</span>
<span class="fc" id="L308">                min2.multiply(a0, mc)</span>
<span class="fc" id="L309">                    .multiply(</span>
<span class="fc" id="L310">                        min1.subtract(</span>
<span class="fc" id="L311">                                min2.multiply(</span>
<span class="fc" id="L312">                                    z0.subtract(min1).divide(z0, 30, RoundingMode.DOWN), mc))</span>
<span class="fc" id="L313">                            .divide(z0, 30, RoundingMode.DOWN),</span>
                        mc)),
            mc)
<span class="fc" id="L316">        .multiply(poolPerformance, mc);</span>
  }

  // calculate R in the formula
  public BigDecimal calculateTotalAvailableReward(
      BigInteger reserves, BigInteger fee, EpochParam epochParam, int totalBlockMinted) {
<span class="fc" id="L322">    var treasuryRate = new BigDecimal(epochParam.getTreasuryGrowthRate().toString());</span>
<span class="fc" id="L323">    var expansionRate = new BigDecimal(epochParam.getMonetaryExpandRate().toString());</span>
    BigDecimal eta;
<span class="fc" id="L325">    MathContext mc = new MathContext(18, RoundingMode.DOWN);</span>
<span class="fc bfc" id="L326" title="All 2 branches covered.">    if (epochParam.getDecentralisation() &gt;= Double.valueOf(&quot;0.8&quot;)) {</span>
<span class="fc" id="L327">      eta = BigDecimal.ONE;</span>
    } else {
<span class="fc" id="L329">      BigDecimal slotPerEpoch = new BigDecimal(RewardConstants.EXPECTED_SLOT_PER_EPOCH);</span>
<span class="fc" id="L330">      eta =</span>
<span class="fc" id="L331">          BigDecimal.ONE.min(</span>
              new BigDecimal(totalBlockMinted)
<span class="fc" id="L333">                  .divide(</span>
                      BigDecimal.ONE
<span class="fc" id="L335">                          .subtract(new BigDecimal(epochParam.getDecentralisation().toString()))</span>
<span class="fc" id="L336">                          .multiply(slotPerEpoch, mc),</span>
                      18,
                      RoundingMode.DOWN));
    }

<span class="fc" id="L341">    var rewardPot =</span>
        new BigDecimal(reserves)
<span class="fc" id="L343">            .multiply(expansionRate, mc)</span>
<span class="fc" id="L344">            .multiply(eta, mc)</span>
<span class="fc" id="L345">            .add(new BigDecimal(fee));</span>
<span class="fc" id="L346">    return rewardPot.multiply(BigDecimal.ONE.subtract(treasuryRate), mc);</span>
  }

  public Reward calculatePoolOwnerReward(RewardParam param) {
    BigDecimal rewardAmount;

    // m in the formula
<span class="fc" id="L353">    var poolMargin = new BigDecimal(param.getPoolConfigProjection().getMargin().toString());</span>
    // c in the formula
<span class="fc" id="L355">    var poolFixedCost = new BigDecimal(param.getPoolConfigProjection().getFixedCost());</span>
    // if pool reward less or equal to pool fixed cost -&gt; pool owner's reward = poolReward
<span class="fc" id="L357">    MathContext mc = new MathContext(30, RoundingMode.DOWN);</span>
<span class="pc bpc" id="L358" title="1 of 2 branches missed.">    if (param.getPoolReward().compareTo(poolFixedCost) &lt;= 0) {</span>
<span class="nc" id="L359">      rewardAmount = param.getPoolReward();</span>
    } else { // else apply the formula
<span class="fc" id="L361">      rewardAmount =</span>
<span class="fc" id="L362">          poolFixedCost.add(</span>
              param
<span class="fc" id="L364">                  .getPoolReward()</span>
<span class="fc" id="L365">                  .subtract(poolFixedCost)</span>
<span class="fc" id="L366">                  .multiply(</span>
<span class="fc" id="L367">                      poolMargin.add(</span>
                          BigDecimal.ONE
<span class="fc" id="L369">                              .subtract(poolMargin)</span>
<span class="fc" id="L370">                              .multiply(param.getRelativeStake())</span>
<span class="fc" id="L371">                              .divide(param.getRelativeStakeOfPool(), 30, RoundingMode.DOWN)),</span>
                      mc));
    }
<span class="fc" id="L374">    return Reward.builder()</span>
<span class="fc" id="L375">        .type(RewardType.LEADER)</span>
<span class="fc" id="L376">        .earnedEpoch(param.getEpochNo())</span>
<span class="fc" id="L377">        .spendableEpoch(param.getEpochNo() + 2)</span>
<span class="fc" id="L378">        .addr(StakeAddress.builder().id(param.getStakeAddressId()).build())</span>
<span class="fc" id="L379">        .stakeAddressId(param.getStakeAddressId())</span>
<span class="fc" id="L380">        .pool(PoolHash.builder().id(param.getPoolConfigProjection().getPoolId()).build())</span>
<span class="fc" id="L381">        .poolId(param.getPoolConfigProjection().getPoolId())</span>
<span class="fc" id="L382">        .amount(rewardAmount.toBigInteger())</span>
<span class="fc" id="L383">        .build();</span>
  }

  public Reward calculateMemberReward(RewardParam param) {
    BigDecimal rewardAmount;
    // m in the formula
<span class="fc" id="L389">    var poolMargin = new BigDecimal(param.getPoolConfigProjection().getMargin().toString());</span>
    // c in the formula
<span class="fc" id="L391">    var poolFixedCost = new BigDecimal(param.getPoolConfigProjection().getFixedCost());</span>
    // if pool reward less or equal to pool fixed cost -&gt; member's reward = 0
<span class="pc bpc" id="L393" title="1 of 2 branches missed.">    if (param.getPoolReward().compareTo(poolFixedCost) &lt;= 0) {</span>
<span class="nc" id="L394">      rewardAmount = BigDecimal.ZERO;</span>
    } else { // else apply the formula
<span class="fc" id="L396">      rewardAmount =</span>
          param
<span class="fc" id="L398">              .getPoolReward()</span>
<span class="fc" id="L399">              .subtract(poolFixedCost)</span>
<span class="fc" id="L400">              .multiply(</span>
                  BigDecimal.ONE
<span class="fc" id="L402">                      .subtract(poolMargin)</span>
<span class="fc" id="L403">                      .multiply(param.getRelativeStake())</span>
<span class="fc" id="L404">                      .divide(param.getRelativeStakeOfPool(), 30, RoundingMode.DOWN));</span>
    }
<span class="fc" id="L406">    return Reward.builder()</span>
<span class="fc" id="L407">        .type(RewardType.MEMBER)</span>
<span class="fc" id="L408">        .earnedEpoch(param.getEpochNo())</span>
<span class="fc" id="L409">        .spendableEpoch(param.getEpochNo() + 2)</span>
<span class="fc" id="L410">        .stakeAddressId(param.getStakeAddressId())</span>
<span class="fc" id="L411">        .addr(StakeAddress.builder().id(param.getStakeAddressId()).build())</span>
<span class="fc" id="L412">        .pool(PoolHash.builder().id(param.getPoolConfigProjection().getPoolId()).build())</span>
<span class="fc" id="L413">        .poolId(param.getPoolConfigProjection().getPoolId())</span>
<span class="fc" id="L414">        .amount(rewardAmount.toBigInteger())</span>
<span class="fc" id="L415">        .build();</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>